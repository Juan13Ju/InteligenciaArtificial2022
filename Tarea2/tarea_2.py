# -*- coding: utf-8 -*-
"""Tarea2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MdbpWl5iPIfY1kgtX9gfbqBCaf713Qv5
"""

#Ejercio 2
import numpy as np
class genAlgo:
    def __init__(self, n_pop, iter, r_cross, r_mut, tablero = 8):
        # Aqui definimos el tamaño del tablero  
        self.tablero = tablero
        # Tamaño de la poblacion
        self.n_pop = n_pop
        # Numero de generaciones
        self.iter = iter
        # crossover rate
        self.r_cross = r_cross
        # mutation rate
        self.r_mut = r_mut
        # El numero maximo de conflictos para el tamaño del tablero
        self.maxConflicts = self.getMaxConflicts()

    # Funcion para determinar los conflictos de un gen
    def countConflicts(self, gen):
        conflictos = 0
        for i in range(self.tablero):
            for j in range(i+1, self.tablero):
                # Conflictos horizontales
                if(gen[i] == gen[j]):
                    conflictos = conflictos + 1
                # Conflictos diagonales
                if(abs(i-j) == abs(gen[i] - gen[j])):
                    conflictos = conflictos + 1
        return conflictos


    # Funcion para determinar la mayor cantidad de conflictos para un tamaño de tabla
    def getMaxConflicts(self):
        # Ya que aun no se me ocurre una formula, pero creo tener la idea de como generar una configuracion
        # con el mayor numero de conflictos, vamos a generar esa configuracion y contar los conflictos
        gen = list()
        # La idea es que para maximizar los conflictos, cada reina estara en conflicto con otra en la diagonal
        # y otra en la horizontal
        for i in range(self.tablero):
            # if( i % 2 == 0):
            #     gen.append(0)
            # else:
            #     gen.append(1)
            gen.append(0)
        
        # Ahora contamos el numero de conflictos
        maxConflicts = self.countConflicts(gen)
        print(f"El mayor numero de conflictos para {self.tablero} reinas es : {maxConflicts}")
        return maxConflicts

    # Funcion que determina el fitness de un gen en particular
    def fitness(self, gen):
        return self.maxConflicts - self.countConflicts(gen)

    def selection(self, pop, scores, k=3):
        # first random selection
        selection_ix = np.random.randint(len(pop))
        for ix in np.random.randint(0, len(pop), k-1):
            if(scores[ix] > scores[selection_ix]):
                selection_ix = ix
        return pop[selection_ix]

    def crossover(self, p1, p2):
        c1, c2 = p1.copy(), p2.copy()
        if(np.random.rand() < self.r_cross):
            pt = np.random.randint(1, len(p1)-2)
            c1 = p1[:pt] + p2[pt:]
            c2 = p2[:pt] + p1[pt:]
        return [c1, c2]

    def mutation(self, gen):
        for i in range(len(gen)):
            if(np.random.rand() < self.r_mut):
                gen[i] = np.random.randint(0, self.tablero)

    def geneticAlgo(self):
        # Primero generamos la poblacion inicial
        pop = [np.random.randint(0,self.tablero-1, self.tablero).tolist() for _ in range(self.n_pop)]
        best = 0
        bestEval = float("-inf")
        for generation in range(self.iter):
            scores = [self.fitness(g) for g in pop]
            for i in range(self.n_pop):
                if(scores[i] > bestEval):
                    best = pop[i]
                    bestEval = scores[i]
                    print(f"El nuevo mejor gen es : {best}, con fitness : {bestEval}")
            # Elegimos a los mejores genes
            selected = [self.selection(pop, scores) for _ in range(self.n_pop)]
            # Creamos la siguiente generacion
            children = list()
            for i in range(0, self.n_pop, 2):
                p1,p2 = selected[i], selected[i+1]
                # Crossover y mutacion
                for c in self.crossover(p1,p2):
                    self.mutation(c)
                    children.append(c)
            pop = children
        return [best, bestEval]


# Modificar aqui (numero de poblacion, iteraciones, crossover rate, mutation rate, tamaño de tablero)
# Tamaño de tablero es opcional y el valor por default es 8
# Nota : El numero de poblacion debe ser par
nPob = int(input("Ingresa un numero de poblacion por generacion (Debe ser par): "))
it = int(input("Ingresa cuantas generaciones deseas simular: "))
cross = float(input("Ingresa un valor de r_cross en [0,1): "))
mut = float(input("Ingresa un valot de r_mut en [0,1): "))
tablero = int(input("Ingresa un entero con el tamaño del tablero: "))
p = genAlgo(nPob, it, cross, mut, tablero)
mejor = p.geneticAlgo()
mejorGen = mejor[0]
print("----------------")
print(f"La mejor solucion: {mejorGen}")
c = p.countConflicts(mejorGen)
f = p.fitness(mejorGen)
print(f"Conflictos de la solucion : {c}")
print(f"Fitness de la solucion : {f}")

#Ejercicio 3

from copy import deepcopy
import numpy as np
import pandas as pd

#Definimos la constantes que usaremos para el modelo.

def f_1(x,y,z): return 80+184*x+96*y+68*z  #Costo
def f_2(x,y,z): return (0.2*435)+415*x+501*y+300*z #Dureza
def f_3(x,y,z): return (0.2*58)+50*x+82*y+15*z      #Peso
def f_4(x,y,z): return (0.2*430)+439*x+520*y+263*z  #D_Calor
σ=0.2  #Estrategia inicial

# Elaboramos a nuestro primer individuo
    
result = [abs(np.random.normal(0, σ))  for i in range(0, 3)]
result= np.dot(result, 1/(sum(result)+0.2))


# Evalua la funciòn para comprobar las restricciones
def evaluete(lista): 
    w_0=f_1(lista[0], lista[1], lista[2])
    w_1=f_2(lista[0], lista[1], lista[2])
    w_2=f_3(lista[0], lista[1], lista[2])
    w_3=f_4(lista[0], lista[1], lista[2])
    return [w_0, w_1, w_2, w_3]

# Función mutación para crear hijos. Restringida a que la suma de x, y, z sea 1

def mutacion(vector):
    a= [abs(vector[i]+np.random.normal(0, σ))  for i in range(0, len(vector))]
    a= np.dot(a, 1/(sum(a)+0.2))
    
    return a

#Proceso de selecciòn

def seleccion_nat(lista):
    i_t, c, σ=0, 0.817, 0.2 #Definimos contadores que nos ayudaran en el camino
    padre=lista
    padre_V=evaluete(lista)
    hijo=mutacion(lista)
    hijo_V=evaluete(hijo)  #Definimos los respectivos primeros padre e hijo  
    while i_t<=1000:
        H, HT, i=0, 0, 1  #Nuevamente contadores
        while i <= 10: #No. de en cuantas generaciones se reajusta la estrategia.
            correct=0
            if hijo_V[0]<padre_V[0]: correct+=1  #Criterios  de selecciòn
            if hijo_V[1]>400 and hijo_V[1]>padre_V[1]: correct+=1
            if hijo_V[2]<60 and hijo_V[2]<padre_V[2]: correct+=1
            if hijo_V[3]>=410 and hijo_V[3]>padre_V[3]: correct+=1
            if correct>3: #Selecciòn del padre o hijo
                padre_V=deepcopy(hijo_V)
                padre=deepcopy(hijo)
                H+=1
            HT+=1
            i+=1
            hijo=mutacion(padre)
            hijo_V=evaluete(hijo)
            i_t+=1
        e_c=H/HT #Reajuste de la estrategia
        if e_c>0.2: σ=σ/e_c
        elif e_c==0.2: continue
        else: σ=σ*c
            
    return padre  #Regresa los valores de la ultima generaciòn que cumpliò los requisitos



#Solo es represtentaciòn.
coeficientes=[seleccion_nat(result) for i in range(0, 100)]
coe=np.dot(coeficientes, 100) 
coef=pd.DataFrame(data=coe, columns=["Mat_B %", "Mat_C %", "Mat_D %" ])
coef['Mat_A %']=20
valores=[evaluete(i) for i in coeficientes]
df =pd.DataFrame(data=valores, columns=["Costo", "Dureza", "Peso", "D_Calor" ])
df=pd.merge(df, coef, left_index=True, right_index=True)
df=df[df.Dureza > 400]
df=df[df.D_Calor > 410]
df=df[df.Peso <= 60]
df=df.sort_values('Costo')
df=df.reset_index()
df=df.drop(['index'], axis=1)
print("La mejor configuracriòn es:")
print(df.head(1)) #Imprime la mejor configuraciòn hallada

#Ejercio 4.3

import math

def entropia(cadena):

        # obtener la probabilidad de cada caracter en la cadena
        probs = [float(cadena.count(char)) / len(cadena) for char in dict.fromkeys(list(cadena))]

        # obtener la entropia
        entropia = - sum([p * math.log(p) / math.log(2.0) for p in probs])

        return entropia

print(entropia("010100110001110101001100011101010011000111"))
print(entropia("000000000000000000000000000000000000000000"))
print(entropia("010101010101101101110110010101010010111010"))